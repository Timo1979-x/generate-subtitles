1
00:00:00,000 --> 00:00:08,000
After introducing virtual thread as part of Java 21, for some reason this has become a common question.

2
00:00:08,000 --> 00:00:11,000
Is reactive programming dead?

3
00:00:11,000 --> 00:00:19,000
First of all, we have to understand one thing that people have been saying, Java is going to be dead for 20 years.

4
00:00:19,000 --> 00:00:21,000
Is Java dead?

5
00:00:21,000 --> 00:00:26,000
Java is more than 25 years old and we Java developers, we love Java.

6
00:00:26,000 --> 00:00:33,000
The concepts like sealed classes, sealed interfaces, record, record patterns, virtual thread, etc.

7
00:00:33,000 --> 00:00:36,000
Other modern programming languages they already have.

8
00:00:36,000 --> 00:00:42,000
Java team, they have been trained to add all these things one by one for us.

9
00:00:42,000 --> 00:00:46,000
This virtual thread project, the project loom was going on for many years.

10
00:00:46,000 --> 00:00:51,000
The main goal of virtual thread is not to compete with the reactive programming.

11
00:00:51,000 --> 00:00:56,000
Virtual thread will be helpful to make use of the system resources like CPU more efficient.

12
00:00:56,000 --> 00:01:01,000
We will also get the non-blocking IO benefits behind the scenes.

13
00:01:01,000 --> 00:01:11,000
Now this is where the question arises that if I can get the non-blocking IO benefit via virtual thread, then why do we need reactive programming?

14
00:01:11,000 --> 00:01:13,000
It should be dead, right?

15
00:01:13,000 --> 00:01:15,000
I understand the question.

16
00:01:15,000 --> 00:01:22,000
But it is wrong to think that the whole point of reactive programming is to achieve non-blocking IO.

17
00:01:22,000 --> 00:01:25,000
We also have structured concurrency.

18
00:01:25,000 --> 00:01:26,000
But currently it is not.

19
00:01:26,000 --> 00:01:29,000
It is in the preview and its goal is different.

20
00:01:29,000 --> 00:01:34,000
Whatever it is trying to solve is not anything to do with reactive programming.

21
00:01:34,000 --> 00:01:37,000
Then what is reactive programming?

22
00:01:37,000 --> 00:01:43,000
Reactive programming is a programming paradigm, a special implementation of observer design pattern.

23
00:01:43,000 --> 00:01:45,000
It is based on three pillars.

24
00:01:45,000 --> 00:01:51,000
Non-blocking IO, stream-based asynchronous communication with back pressure support.

25
00:01:51,000 --> 00:01:55,000
We need reactive programming to build reactive system.

26
00:01:55,000 --> 00:01:57,000
We understand the first point.

27
00:01:57,000 --> 00:01:59,000
Here we do not have any confusion.

28
00:01:59,000 --> 00:02:05,000
In this video we can understand the second and third points by using an application.

29
00:02:05,000 --> 00:02:11,000
Which I think that it is the perfect example of reactive system.

30
00:02:11,000 --> 00:02:22,000
Before that, Java has already enabled reactive programming by introducing few interfaces as part of the Java util concurrent package, the flow class.

31
00:02:22,000 --> 00:02:24,000
We already have few.

32
00:02:24,000 --> 00:02:31,000
We have few libraries for reactive programming like reactor, Rx, Java 2, Aca streams, etc.

33
00:02:31,000 --> 00:02:37,000
Currently they all use platform threads because that is what we have had before Java 21.

34
00:02:37,000 --> 00:02:45,000
Now as part of Java 21, since we have virtual threads, these libraries, they might start using virtual threads now.

35
00:02:45,000 --> 00:02:50,000
As you see, the reactor, they have already updated to use virtual threads.

36
00:02:50,000 --> 00:02:53,000
So as you see now, these libraries.

37
00:02:53,000 --> 00:02:57,000
They are already going to get the benefit of virtual threads.

38
00:02:57,000 --> 00:03:01,000
So virtual thread is not going to kill reactive programming.

39
00:03:01,000 --> 00:03:09,000
For the past 20-25 years, we have been traditionally programming like client-server, request-response.

40
00:03:09,000 --> 00:03:11,000
This is how we see things.

41
00:03:11,000 --> 00:03:13,000
This is how we have been coding.

42
00:03:13,000 --> 00:03:16,000
But if we consider gRPC, Rsocket, etc.

43
00:03:16,000 --> 00:03:19,000
They can be little bit interactive.

44
00:03:19,000 --> 00:03:21,000
If you have used Rsocket.

45
00:03:21,000 --> 00:03:22,000
You will understand this.

46
00:03:22,000 --> 00:03:26,000
You will understand that it does not see that client and server.

47
00:03:26,000 --> 00:03:30,000
It will be seeing this as two different systems talking to one another.

48
00:03:30,000 --> 00:03:33,000
It is something like two people talking over the phone.

49
00:03:33,000 --> 00:03:43,000
The traditional synchronous blocking style code will not be helpful as it does not provide the necessary tools for this communication.

50
00:03:43,000 --> 00:03:48,000
This is why we need something slightly different which is reactive programming.

51
00:03:48,000 --> 00:03:50,000
Reactive programming is a tool to build reactive systems.

52
00:03:50,000 --> 00:03:53,000
Reactive programming is a tool to build reactive systems.

53
00:03:53,000 --> 00:04:00,000
Now let's take a look at the second and third point by using one popular application.

54
00:04:00,000 --> 00:04:03,000
That application is ChatGPT.

55
00:04:03,000 --> 00:04:05,000
Now I want you to observe this.

56
00:04:05,000 --> 00:04:08,000
I am going to ask a simple question.

57
00:04:08,000 --> 00:04:10,000
Let's see what it does.

58
00:04:10,000 --> 00:04:15,000
As soon as I ask a question, it is trying to give me a response.

59
00:04:15,000 --> 00:04:16,000
Right?

60
00:04:16,000 --> 00:04:19,000
In the example what we just saw.

61
00:04:19,000 --> 00:04:24,000
The ChatGPT took almost 7 seconds to provide me the full response.

62
00:04:24,000 --> 00:04:29,000
Now let's imagine we do the traditional synchronous blocking style programming.

63
00:04:29,000 --> 00:04:32,000
You ask a question.

64
00:04:32,000 --> 00:04:34,000
The answer will be prepared.

65
00:04:34,000 --> 00:04:37,000
And it might take 7 seconds.

66
00:04:37,000 --> 00:04:40,000
Then we return the answer.

67
00:04:40,000 --> 00:04:43,000
Now think about the user experience.

68
00:04:43,000 --> 00:04:44,000
How it will be.

69
00:04:44,000 --> 00:04:45,000
You ask a question.

70
00:04:45,000 --> 00:04:48,000
For the next 7 seconds nothing is going to happen.

71
00:04:48,000 --> 00:04:52,000
Then you get the response.

72
00:04:52,000 --> 00:04:54,000
You are getting right.

73
00:04:54,000 --> 00:04:58,000
Because this is how the traditional programming we are doing actually.

74
00:04:58,000 --> 00:05:03,000
So we prepare the answer and we return the actual object.

75
00:05:03,000 --> 00:05:05,000
The T object.

76
00:05:05,000 --> 00:05:10,000
Because of this return type, whoever called this method.

77
00:05:10,000 --> 00:05:17,000
They will have to wait for this method to complete till the answer is returned to the caller.

78
00:05:17,000 --> 00:05:18,000
Ok.

79
00:05:18,000 --> 00:05:21,000
Now in the reactive programming.

80
00:05:21,000 --> 00:05:23,000
When someone calls this method.

81
00:05:23,000 --> 00:05:25,000
We do not block the caller.

82
00:05:25,000 --> 00:05:27,000
We immediately return something.

83
00:05:27,000 --> 00:05:29,000
So that something right.

84
00:05:29,000 --> 00:05:32,000
In the reactive programming normally we call that publisher.

85
00:05:32,000 --> 00:05:38,000
So the publisher you have to imagine this something like a pipe.

86
00:05:38,000 --> 00:05:41,000
So we as soon as the method is invoked.

87
00:05:41,000 --> 00:05:43,000
We return the publisher.

88
00:05:43,000 --> 00:05:46,000
Then we prepare the answer asynchronous.

89
00:05:46,000 --> 00:05:49,000
Then we send the answer via that pipe.

90
00:05:49,000 --> 00:05:51,000
As soon as it is available.

91
00:05:51,000 --> 00:05:56,000
In the traditional programming you prepare the big answer and you send at once.

92
00:05:56,000 --> 00:05:58,000
In the reactive programming you send.

93
00:05:58,000 --> 00:06:00,000
You can send them as chunks.

94
00:06:00,000 --> 00:06:02,000
As soon as it is available.

95
00:06:02,000 --> 00:06:04,000
As soon as you have something available.

96
00:06:04,000 --> 00:06:06,000
You can keep on sending them.

97
00:06:06,000 --> 00:06:10,000
The reactive programming might still take 7 seconds to prepare the answer.

98
00:06:10,000 --> 00:06:11,000
That's fine.

99
00:06:11,000 --> 00:06:14,000
But the idea here is we do not block the answer.

100
00:06:14,000 --> 00:06:17,000
And we provide something to the caller as soon as something is available.

101
00:06:17,000 --> 00:06:19,000
Because of that it will look responsive.

102
00:06:19,000 --> 00:06:22,000
Now if you compare the if you check the chat GPD behavior right.

103
00:06:22,000 --> 00:06:26,000
It didn't take 7 seconds and it didn't give me the complete response after 7 seconds.

104
00:06:26,000 --> 00:06:29,000
Instead as soon as something is available it kept on sending to the screen.

105
00:06:29,000 --> 00:06:32,000
So that we could see and the application looked responsive.

106
00:06:32,000 --> 00:06:33,000
So that's fine.

107
00:06:33,000 --> 00:06:35,000
But the idea here is we do not block the caller.

108
00:06:35,000 --> 00:06:38,000
And we provide something to the caller as soon as something is available.

109
00:06:38,000 --> 00:06:40,000
Because of that it will look responsive.

110
00:06:40,000 --> 00:06:44,000
So that we could see and the application looked responsive.

111
00:06:44,000 --> 00:06:47,000
Completable feature is not reactive.

112
00:06:47,000 --> 00:06:52,000
It's mainly because it cannot send stream of values.

113
00:06:52,000 --> 00:06:56,000
Completable feature can provide only one value at a time.

114
00:06:56,000 --> 00:06:59,000
You cannot send stream of values.

115
00:06:59,000 --> 00:07:01,000
Now let's come back to chat GPD.

116
00:07:01,000 --> 00:07:03,000
And I am going to ask the same question.

117
00:07:03,000 --> 00:07:08,000
And I would like to show another important feature actually.

118
00:07:08,000 --> 00:07:09,000
So if I hit enter.

119
00:07:09,000 --> 00:07:12,000
Now it's trying to give me something as usual.

120
00:07:12,000 --> 00:07:14,000
I say stop.

121
00:07:14,000 --> 00:07:16,000
And it stopped.

122
00:07:16,000 --> 00:07:21,000
In the second example I asked the question.

123
00:07:21,000 --> 00:07:26,000
And chat GPD was giving me the stream of answer.

124
00:07:26,000 --> 00:07:28,000
It did not complete the answer fully.

125
00:07:28,000 --> 00:07:32,000
But as soon as I saw the rest endpoint one example.

126
00:07:32,000 --> 00:07:35,000
I realized oh this is how I have to do.

127
00:07:35,000 --> 00:07:36,000
Okay I stopped.

128
00:07:36,000 --> 00:07:38,000
So when I say stop.

129
00:07:38,000 --> 00:07:39,000
Then it stopped.

130
00:07:39,000 --> 00:07:40,000
You are getting right.

131
00:07:40,000 --> 00:07:44,000
Sometimes you might not be interested in the complete response.

132
00:07:44,000 --> 00:07:47,000
The complete response might take 30 seconds, 30 minutes.

133
00:07:47,000 --> 00:07:48,000
Who knows.

134
00:07:48,000 --> 00:07:50,000
So it might keep on sending the response.

135
00:07:50,000 --> 00:07:54,000
However you are actually satisfied with the partial response.

136
00:07:54,000 --> 00:07:57,000
As soon as you received this response.

137
00:07:57,000 --> 00:07:59,000
Immediately you are satisfied.

138
00:07:59,000 --> 00:08:00,000
Yeah this is what I need.

139
00:08:00,000 --> 00:08:01,000
Stop.

140
00:08:01,000 --> 00:08:02,000
So as soon as you say stop.

141
00:08:02,000 --> 00:08:03,000
It stopped.

142
00:08:03,000 --> 00:08:04,000
You are getting right.

143
00:08:04,000 --> 00:08:08,000
So you have the ability to stop the execution whenever you like.

144
00:08:08,000 --> 00:08:10,000
If you check the traditional programming.

145
00:08:10,000 --> 00:08:12,000
You will get the answer only after 7 seconds.

146
00:08:12,000 --> 00:08:13,000
Or only after 30 seconds.

147
00:08:13,000 --> 00:08:14,000
So you cannot cancel.

148
00:08:14,000 --> 00:08:15,000
Because you cannot see anything until the answer arrives.

149
00:08:15,000 --> 00:08:16,000
You are getting right.

150
00:08:16,000 --> 00:08:17,000
But on the reactive programming since we are sending the answer in chunks.

151
00:08:17,000 --> 00:08:18,000
It is a stream-based communication.

152
00:08:18,000 --> 00:08:19,000
If you are already satisfied with the partial response.

153
00:08:19,000 --> 00:08:20,000
You can simply cancel the execution.

154
00:08:20,000 --> 00:08:21,000
So that this publisher does not have to go to the website and see the response.

155
00:08:21,000 --> 00:08:22,000
So if you want to see the response you can just click on the handover button.

156
00:08:22,000 --> 00:08:23,000
And then you can see it will get sent to the website.

157
00:08:23,000 --> 00:08:24,000
And then you can see it is sent to the website.

158
00:08:24,000 --> 00:08:25,000
And then you can see it is sent to the website.

159
00:08:25,000 --> 00:08:26,000
So this is what I mean.

160
00:08:26,000 --> 00:08:27,000
It is a stream-based communication.

161
00:08:27,000 --> 00:08:28,000
So I can see what is happening.

162
00:08:28,000 --> 00:08:32,740
in chunks. It's a stream-based communication. If you are already satisfied with the partial

163
00:08:32,740 --> 00:08:38,580
response, you can simply cancel the execution so that this publisher does not have to do

164
00:08:38,580 --> 00:08:43,720
unnecessary work. Let's come back to this one more time. This time I have a different question

165
00:08:43,720 --> 00:08:49,840
to ask. Show me the first thousand prime numbers. This is what I'm going to ask. Let's see what it

166
00:08:49,840 --> 00:08:59,120
does. So it's trying to give me all the prime numbers. So let's observe this. If you notice,

167
00:08:59,120 --> 00:09:06,060
it stopped at 282 and it did not give me the complete thousand prime numbers. Instead,

168
00:09:06,400 --> 00:09:13,640
it stopped at 282 and it gives me, it shows this button saying that should I still continue

169
00:09:13,640 --> 00:09:19,820
generating? Am I still here? This is how it behaves actually. So if you are still here,

170
00:09:19,820 --> 00:09:27,040
if I want to see the answer further, I can click on it so that it simply continues from where it

171
00:09:27,040 --> 00:09:35,020
stopped, but it did not give me all the thousand up front. If you sit and silently observe this,

172
00:09:35,020 --> 00:09:44,060
it will stop at some point. Again, it stopped at 538 and if I want to continue, I can continue.

173
00:09:44,780 --> 00:09:49,500
Why I wanted to show that example is mainly because that is what,

174
00:09:49,820 --> 00:09:56,780
the back pressure is. For example, in the traditional programming, again, we ask a question,

175
00:09:57,200 --> 00:10:01,780
we prepare the complete response, then we provide. In the reactive programming,

176
00:10:02,020 --> 00:10:08,580
since we do the stream-based communication, just because the caller asks, hey, can you generate

177
00:10:08,580 --> 00:10:14,040
one million items? The producer does not have to generate all the one million items and keep on

178
00:10:14,040 --> 00:10:19,240
sending them one by one. What if the caller is not using the response we are sending?

179
00:10:19,240 --> 00:10:25,240
So this is what we are saying, back pressure, that is, you keep on generating the response.

180
00:10:25,620 --> 00:10:33,240
If you think that the caller is not using the response or is a slow consumer, the producer

181
00:10:33,240 --> 00:10:40,020
will automatically stop. That is the back pressure. So it will not unnecessarily do any work.

182
00:10:40,340 --> 00:10:47,080
The producer will automatically stop when it thinks that the consumer is not consuming the items.

183
00:10:47,080 --> 00:10:49,080
So this is something we can,

184
00:10:49,240 --> 00:10:54,120
achieve in reactive programming. In the traditional programming style, we cannot do that.

185
00:10:54,920 --> 00:11:02,840
So in order for the producer to keep producing the items, the consumer also has to consume the items

186
00:11:02,840 --> 00:11:08,320
at the same rate. If the consumer is slow, the producer will stop producing and it will do something else.

187
00:11:08,640 --> 00:11:13,440
Then it will start again only when the consumer is making some progress.

188
00:11:13,680 --> 00:11:16,780
In this case, we clicked on the continue generating button, right?

189
00:11:19,240 --> 00:11:22,920
So the producer will kind of tell the chat GPT application to keep producing.

190
00:11:22,920 --> 00:11:28,780
Similarly, we have to acknowledge or we have to consume the items so that it will keep producing.

191
00:11:29,720 --> 00:11:33,640
Reactive programming is a tool to build a reactive system.

192
00:11:33,640 --> 00:11:38,360
So it does not have to be like two different methods in a class.

193
00:11:38,780 --> 00:11:43,620
It can be completely two different systems. The producer could be a database.

194
00:11:43,620 --> 00:11:48,960
So you might want to execute a query for which it might be sending the response as a stream.

195
00:11:49,240 --> 00:11:51,240
You are getting right.

196
00:11:51,240 --> 00:11:56,920
Now if you compare this with the virtual threads and the structured concurrency,

197
00:11:56,920 --> 00:12:00,600
definitely virtual thread is going to help with the non-blocking I.O.

198
00:12:00,600 --> 00:12:08,360
However, virtual thread or the structured concurrency is not going to help with the back pressure or stream-based asynchronous communication.

199
00:12:09,240 --> 00:12:16,840
When we say stream-based communication, is this something like a completely even driven architecture or something like a Kafka stream?

200
00:12:16,840 --> 00:12:19,160
If you ask like this, no, it doesn't.

201
00:12:19,240 --> 00:12:21,960
It doesn't have to be like that.

202
00:12:22,840 --> 00:12:26,760
We can also use HTTP, for example, in Spring Web Flux.

203
00:12:26,760 --> 00:12:28,440
That is what we use, right?

204
00:12:28,440 --> 00:12:29,400
Is HTTP.

205
00:12:29,960 --> 00:12:33,160
But most of us, we are still using HTTP 1.1.

206
00:12:33,800 --> 00:12:38,040
But Spring Web Flux also supports HTTP 2.0 NetE.

207
00:12:39,000 --> 00:12:43,640
In the HTTP 2.0, we can have stream-based communication.

208
00:12:43,640 --> 00:12:48,200
HTTP 2.0 is different, a lot better than HTTP 1.1.

209
00:12:48,760 --> 00:12:49,240
So we can use it.

210
00:12:49,240 --> 00:12:53,400
We can have stream-based communication in HTTP 2.0.


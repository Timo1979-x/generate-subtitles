1
00:00:00,000 --> 00:00:08,000
After introducing virtual thread as part of Java 21, for some reason this has become a common question.

2
00:00:08,000 --> 00:00:11,000
Is reactive programming dead?

3
00:00:11,000 --> 00:00:19,000
First of all, we have to understand one thing that people have been saying, Java is going to be dead for 20 years.

4
00:00:19,000 --> 00:00:21,000
Is Java dead?

5
00:00:21,000 --> 00:00:26,000
Java is more than 25 years old and we Java developers, we love Java.

6
00:00:26,000 --> 00:00:33,000
The concepts like sealed classes, sealed interfaces, record, record patterns, virtual thread, etc.

7
00:00:33,000 --> 00:00:36,000
Other modern programming languages they already have.

8
00:00:36,000 --> 00:00:42,000
Java team, they have been trained to add all these things one by one for us.

9
00:00:42,000 --> 00:00:46,000
This virtual thread project, the project loom was going on for many years.

10
00:00:46,000 --> 00:00:51,000
The main goal of virtual thread is not to compete with the reactive programming.

11
00:00:51,000 --> 00:00:56,000
Virtual thread will be helpful to make use of the system resources like CPU more efficient.

12
00:00:56,000 --> 00:01:01,000
We will also get the non-blocking IO benefits behind the scenes.

13
00:01:01,000 --> 00:01:11,000
Now this is where the question arises that if I can get the non-blocking IO benefit via virtual thread, then why do we need reactive programming?

14
00:01:11,000 --> 00:01:13,000
It should be dead, right?

15
00:01:13,000 --> 00:01:15,000
I understand the question.

16
00:01:15,000 --> 00:01:22,000
But it is wrong to think that the whole point of reactive programming is to achieve non-blocking IO.

17
00:01:22,000 --> 00:01:25,000
We also have structured concurrency.

18
00:01:25,000 --> 00:01:26,000
But currently it is not.

19
00:01:26,000 --> 00:01:29,000
It is in the preview and its goal is different.

20
00:01:29,000 --> 00:01:34,000
Whatever it is trying to solve is not anything to do with reactive programming.

21
00:01:34,000 --> 00:01:37,000
Then what is reactive programming?

22
00:01:37,000 --> 00:01:43,000
Reactive programming is a programming paradigm, a special implementation of observer design pattern.

23
00:01:43,000 --> 00:01:45,000
It is based on three pillars.

24
00:01:45,000 --> 00:01:51,000
Non-blocking IO, stream-based asynchronous communication with the back pressure support.

25
00:01:51,000 --> 00:01:55,000
We need reactive programming to build reactive system.

26
00:01:55,000 --> 00:01:57,000
We understand the first point.

27
00:01:57,000 --> 00:01:59,000
Here we do not have any confusion.

28
00:01:59,000 --> 00:02:05,000
In this video we can understand the second and third points by using an application.

29
00:02:05,000 --> 00:02:11,000
Which I think that it is the perfect example of reactive system.

30
00:02:11,000 --> 00:02:22,000
Before that, Java has already enabled reactive programming by introducing few interfaces as part of the Java util concurrent package, the flow class.

31
00:02:22,000 --> 00:02:24,000
We already have few.

32
00:02:24,000 --> 00:02:31,000
We have few libraries for reactive programming like reactor, Rx, Java 2, Aca streams, etc.

33
00:02:31,000 --> 00:02:37,000
Currently they all use platform threads because that is what we have had before Java 21.

34
00:02:37,000 --> 00:02:45,000
Now as part of Java 21, since we have virtual threads, these libraries, they might start using virtual threads now.

35
00:02:45,000 --> 00:02:50,000
As you see, the reactor, they have already updated to use virtual threads.

36
00:02:50,000 --> 00:02:53,000
So as you see now, these libraries.

37
00:02:53,000 --> 00:02:57,000
They are already going to get the benefit of virtual threads.

38
00:02:57,000 --> 00:03:01,000
So virtual thread is not going to kill reactive programming.

39
00:03:01,000 --> 00:03:09,000
For the past 20-25 years, we have been traditionally programming like client-server, request-response.

40
00:03:09,000 --> 00:03:11,000
This is how we see things.

41
00:03:11,000 --> 00:03:13,000
This is how we have been coding.

42
00:03:13,000 --> 00:03:16,000
But if we consider gRPC, Rsocket, etc.

43
00:03:16,000 --> 00:03:19,000
They can be little bit interactive.

44
00:03:19,000 --> 00:03:21,000
If you have used Rsocket.

45
00:03:21,000 --> 00:03:22,000
You will understand this.

46
00:03:22,000 --> 00:03:26,000
You will understand that it does not see that client and server.

47
00:03:26,000 --> 00:03:30,000
It will be seeing this as two different systems talking to one another.

48
00:03:30,000 --> 00:03:33,000
It is something like two people talking over the phone.

49
00:03:33,000 --> 00:03:43,000
The traditional synchronous blocking style code will not be helpful as it does not provide the necessary tools for this communication.

50
00:03:43,000 --> 00:03:48,000
This is why we need something slightly different which is reactive programming.

51
00:03:48,000 --> 00:03:50,000
Reactive programming is a tool to build reactive systems.

52
00:03:50,000 --> 00:03:53,000
Reactive programming is a tool to build reactive systems.

53
00:03:53,000 --> 00:04:00,000
Now let's take a look at the second and third point by using one popular application.

54
00:04:00,000 --> 00:04:03,000
That application is ChatGPT.

55
00:04:03,000 --> 00:04:05,000
Now I want you to observe this.

56
00:04:05,000 --> 00:04:08,000
I am going to ask a simple question.

57
00:04:08,000 --> 00:04:10,000
Let's see what it does.

58
00:04:10,000 --> 00:04:15,000
As soon as I ask a question, it is trying to give me a response.

59
00:04:15,000 --> 00:04:16,000
Right?

60
00:04:16,000 --> 00:04:19,000
In the example what we just saw.

61
00:04:19,000 --> 00:04:24,000
The ChatGPT took almost 7 seconds to provide me the full response.

62
00:04:24,000 --> 00:04:29,000
Now let's imagine we do the traditional synchronous blocking style programming.

63
00:04:29,000 --> 00:04:32,000
You ask a question.

64
00:04:32,000 --> 00:04:34,000
The answer will be prepared.

65
00:04:34,000 --> 00:04:37,000
And it might take 7 seconds.

66
00:04:37,000 --> 00:04:40,000
Then we return the answer.

67
00:04:40,000 --> 00:04:43,000
Now think about the user experience.

68
00:04:43,000 --> 00:04:44,000
How it will be.

69
00:04:44,000 --> 00:04:45,000
You ask a question.

70
00:04:45,000 --> 00:04:48,000
For the next 7 seconds nothing is going to happen.

71
00:04:48,000 --> 00:04:52,000
Then you get the response.

72
00:04:52,000 --> 00:04:54,000
You are getting right.

73
00:04:54,000 --> 00:04:58,000
Because this is how the traditional programming we are doing actually.

74
00:04:58,000 --> 00:05:03,000
So we prepare the answer and we return the actual object.

75
00:05:03,000 --> 00:05:05,000
The T object.

76
00:05:05,000 --> 00:05:10,000
Because of this return type, whoever called this method.

77
00:05:10,000 --> 00:05:17,000
They will have to wait for this method to complete till the answer is returned to the caller.

78
00:05:17,000 --> 00:05:18,000
Ok.

79
00:05:18,000 --> 00:05:21,000
Now in the reactive programming.

80
00:05:21,000 --> 00:05:23,000
When someone calls this method.

81
00:05:23,000 --> 00:05:25,000
We do not block the caller.

82
00:05:25,000 --> 00:05:27,000
We immediately return something.

83
00:05:27,000 --> 00:05:29,000
So that something right.

84
00:05:29,000 --> 00:05:32,000
In the reactive programming normally we call that publisher.

85
00:05:32,000 --> 00:05:38,000
So the publisher you have to imagine this something like a pipe.

86
00:05:38,000 --> 00:05:41,000
So we as soon as the method is invoked.

87
00:05:41,000 --> 00:05:43,000
We return the publisher.

88
00:05:43,000 --> 00:05:46,000
Then we prepare the answer asynchronous.

89
00:05:46,000 --> 00:05:49,000
Then we send the answer via that pipe.

90
00:05:49,000 --> 00:05:51,000
As soon as it is available.

91
00:05:51,000 --> 00:05:56,000
In the traditional programming you prepare the big answer and you send at once.

92
00:05:56,000 --> 00:05:58,000
In the reactive programming you send.

93
00:05:58,000 --> 00:06:00,000
You can send them as chunks.

94
00:06:00,000 --> 00:06:02,000
As soon as it is available.

95
00:06:02,000 --> 00:06:04,000
As soon as you have something available.

96
00:06:04,000 --> 00:06:06,000
You can keep on sending them.

97
00:06:06,000 --> 00:06:10,000
The reactive programming might still take 7 seconds to prepare the answer.

98
00:06:10,000 --> 00:06:11,000
That's fine.

99
00:06:11,000 --> 00:06:14,000
But the idea here is we do not block the answer.

100
00:06:14,000 --> 00:06:17,000
And we provide something to the caller as soon as something is available.

101
00:06:17,000 --> 00:06:19,000
Because of that it will look responsive.

102
00:06:19,000 --> 00:06:22,000
Now if you compare the if you check the chat GPD behavior right.

103
00:06:22,000 --> 00:06:26,000
It didn't take 7 seconds and it didn't give me the complete response after 7 seconds.

104
00:06:26,000 --> 00:06:29,000
Instead as soon as something is available it kept on sending to the screen.

105
00:06:29,000 --> 00:06:32,000
So that we could see and the application looked responsive.

106
00:06:32,000 --> 00:06:33,000
So that's fine.

107
00:06:33,000 --> 00:06:35,000
But the idea here is we do not block the caller.

108
00:06:35,000 --> 00:06:38,000
And we provide something to the caller as soon as something is available.

109
00:06:38,000 --> 00:06:40,000
Because of that it will look responsive.

110
00:06:40,000 --> 00:06:44,000
So that we could see and the application looked responsive.

111
00:06:44,000 --> 00:06:47,000
Completable feature is not reactive.

112
00:06:47,000 --> 00:06:52,000
It's mainly because it cannot send stream of values.

113
00:06:52,000 --> 00:06:56,000
Completable feature can provide only one value at a time.

114
00:06:56,000 --> 00:06:59,000
You cannot send stream of values.

115
00:06:59,000 --> 00:07:01,000
Now let's come back to chat GPD.

116
00:07:01,000 --> 00:07:03,000
And I am going to ask the same question.

117
00:07:03,000 --> 00:07:08,000
And I would like to show another important feature actually.

118
00:07:08,000 --> 00:07:09,000
So if I hit enter.

119
00:07:09,000 --> 00:07:12,000
Now it's trying to give me something as usual.

120
00:07:12,000 --> 00:07:14,000
I say stop.

121
00:07:14,000 --> 00:07:16,000
And it stopped.

122
00:07:16,000 --> 00:07:21,000
In the second example I asked the question.

123
00:07:21,000 --> 00:07:26,000
And chat GPD was giving me the stream of answer.

124
00:07:26,000 --> 00:07:28,000
It did not complete the answer fully.

125
00:07:28,000 --> 00:07:32,000
But as soon as I saw the rest endpoint one example.

126
00:07:32,000 --> 00:07:35,000
I realized oh this is how I have to do.

127
00:07:35,000 --> 00:07:36,000
Okay I stopped.

128
00:07:36,000 --> 00:07:38,000
So when I say stop.

129
00:07:38,000 --> 00:07:39,000
Then it stopped.

130
00:07:39,000 --> 00:07:40,000
You are getting right.

131
00:07:40,000 --> 00:07:44,000
Sometimes you might not be interested in the complete response.

132
00:07:44,000 --> 00:07:47,000
The complete response might take 30 seconds, 30 minutes.

133
00:07:47,000 --> 00:07:48,000
Who knows.

134
00:07:48,000 --> 00:07:50,000
So it might keep on sending the response.

135
00:07:50,000 --> 00:07:54,000
However you are actually satisfied with the partial response.

136
00:07:54,000 --> 00:07:57,000
As soon as you received this response.

137
00:07:57,000 --> 00:07:59,000
Immediately you are satisfied.

138
00:07:59,000 --> 00:08:00,000
Yeah this is what I need.

139
00:08:00,000 --> 00:08:01,000
Stop.

140
00:08:01,000 --> 00:08:02,000
So as soon as you say stop.

141
00:08:02,000 --> 00:08:03,000
It stopped.

142
00:08:03,000 --> 00:08:04,000
You are getting right.

143
00:08:04,000 --> 00:08:08,000
So you have the ability to stop the execution whenever you like.

144
00:08:08,000 --> 00:08:11,000
If you check the traditional programming.

145
00:08:11,000 --> 00:08:16,000
You will get the answer only after 7 seconds or only after 30 seconds.

146
00:08:16,000 --> 00:08:17,000
So you cannot cancel.

147
00:08:17,000 --> 00:08:21,000
Because you cannot see anything until the answer arrives.

148
00:08:21,000 --> 00:08:22,000
You are getting right.

149
00:08:22,000 --> 00:08:26,000
But on the reactive programming since we are sending the answer in chunks.

150
00:08:26,000 --> 00:08:28,000
It's a stream based communication.

151
00:08:28,000 --> 00:08:33,000
If you are already satisfied with the partial response you can simply cancel the execution.

152
00:08:33,000 --> 00:08:37,000
So that this publisher does not have to pay you for the response.

153
00:08:37,000 --> 00:08:41,000
The publisher does not have to do unnecessary work.

154
00:08:41,000 --> 00:08:42,000
Let's come back to this one more time.

155
00:08:42,000 --> 00:08:44,000
This time I have a different question to ask.

156
00:08:44,000 --> 00:08:47,000
Show me the first 1000 prime numbers.

157
00:08:47,000 --> 00:08:49,000
This is what I am going to ask.

158
00:08:49,000 --> 00:08:50,000
Let's see what it does.

159
00:08:50,000 --> 00:08:54,000
So it's trying to give me all the prime numbers.

160
00:08:54,000 --> 00:08:58,000
So let's observe this.

161
00:08:58,000 --> 00:09:01,000
If you notice it stopped at 282.

162
00:09:01,000 --> 00:09:05,000
And it did not give me the complete 1000 prime numbers.

163
00:09:05,000 --> 00:09:06,000
Instead it stopped at 282.

164
00:09:06,000 --> 00:09:14,000
And it gives me, it shows this button saying that should I still continue generating.

165
00:09:14,000 --> 00:09:16,000
Am I still here?

166
00:09:16,000 --> 00:09:19,000
This is how it behaves actually.

167
00:09:19,000 --> 00:09:28,000
So if I want to see the answer further I can click on it so that it simply continues from where it stopped.

168
00:09:28,000 --> 00:09:32,000
But it did not give me all the 1000 up front.

169
00:09:32,000 --> 00:09:34,000
If you sit and silently observe this it will stop.

170
00:09:34,000 --> 00:09:35,000
It will stop.

171
00:09:35,000 --> 00:09:37,000
It will stop at some point.

172
00:09:37,000 --> 00:09:41,000
Again it stopped at 538.

173
00:09:41,000 --> 00:09:44,000
And if I want to continue I can continue.

174
00:09:44,000 --> 00:09:52,000
Why I wanted to show that example is mainly because that is what the back pressure is.

175
00:09:52,000 --> 00:09:57,000
For example in the traditional programming again we ask a question.

176
00:09:57,000 --> 00:09:59,000
We prepare the complete response.

177
00:09:59,000 --> 00:10:00,000
Then we provide.

178
00:10:00,000 --> 00:10:05,000
In the reactive programming since we do the stream based communication.

179
00:10:05,000 --> 00:10:10,000
Just because the caller asks hey can you generate 1 million items.

180
00:10:10,000 --> 00:10:16,000
The producer does not have to generate all the 1 million items and keep on sending them one by one.

181
00:10:16,000 --> 00:10:19,000
What if the caller is not using the response we are sending.

182
00:10:19,000 --> 00:10:25,000
So this is what we are saying the we are saying back pressure that is you keep on generating the response.

183
00:10:25,000 --> 00:10:32,000
If you think that the caller is not using the response or is a slow consumer.

184
00:10:32,000 --> 00:10:34,000
The producer will automatically stop.

185
00:10:34,000 --> 00:10:36,000
That is the back pressure.

186
00:10:36,000 --> 00:10:40,000
So it will not unnecessarily do any work.

187
00:10:40,000 --> 00:10:47,000
The producer will automatically stop when it thinks that the consumer is not consuming the items.

188
00:10:47,000 --> 00:10:51,000
So this is something we can achieve in reactive programming.

189
00:10:51,000 --> 00:10:54,000
In the traditional programming style we cannot do that.

190
00:10:54,000 --> 00:10:59,000
So in order for the producer to keep producing the items.

191
00:10:59,000 --> 00:11:03,000
The consumer also has to consume the items at the same rate.

192
00:11:03,000 --> 00:11:08,000
If the consumer is slow the producer will stop producing and it will do something else.

193
00:11:08,000 --> 00:11:13,000
Then it will start again only when the consumer is making some progress.

194
00:11:13,000 --> 00:11:16,000
In this case we clicked on the continue generating button right.

195
00:11:16,000 --> 00:11:23,000
So we kind of acknowledge or we kind of tell the chat GPT application to keep producing.

196
00:11:23,000 --> 00:11:29,000
Similarly we have to acknowledge or we have to consume the items so that it will keep producing.

197
00:11:29,000 --> 00:11:32,000
Reactive programming is a tool to build reactive programming.

198
00:11:33,000 --> 00:11:38,000
So it does not have to be like two different methods in a class.

199
00:11:38,000 --> 00:11:41,000
It can be completely two different systems.

200
00:11:41,000 --> 00:11:43,000
The producer could be a database.

201
00:11:43,000 --> 00:11:49,000
So you might want to execute a query for which it might be sending the response as a stream.

202
00:11:49,000 --> 00:11:51,000
You are getting right.

203
00:11:51,000 --> 00:11:56,000
Now if you compare this with the virtual threads and the structured concurrency.

204
00:11:56,000 --> 00:12:00,000
Definitely virtual thread is going to help with the non-blocking I.O.

205
00:12:00,000 --> 00:12:03,000
However virtual thread are the structured concurrency.

206
00:12:03,000 --> 00:12:09,000
Is not going to help with the back pressure or stream based asynchronous communication.

207
00:12:09,000 --> 00:12:15,000
When we say stream based communication is this something like a completely even driven architecture.

208
00:12:15,000 --> 00:12:18,000
Or something like a Kafka stream if you ask like this.

209
00:12:18,000 --> 00:12:22,000
No it does not have to be like that.

210
00:12:22,000 --> 00:12:26,000
We can also use HTTP for example in Spring Web Flex.

211
00:12:26,000 --> 00:12:29,000
That is what we use right is HTTP.

212
00:12:29,000 --> 00:12:32,000
But most of us we are still using HTTP 1.1.

213
00:12:32,000 --> 00:12:38,000
But Spring Web Flex also supports HTTP 2.

214
00:12:38,000 --> 00:12:43,000
In the HTTP 2 we can have stream based communication.

215
00:12:43,000 --> 00:12:48,000
HTTP 2 is different lot better than HTTP 1.1.

216
00:12:48,000 --> 00:12:53,000
So we can have stream based communication in HTTP 2.

